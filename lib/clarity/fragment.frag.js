'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fragment = "#define GLSLIFY 1\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nuniform float value;\nuniform vec2 px;\n\nfloat Lum(vec3 c){\n    return 0.299*c.r + 0.587*c.g + 0.114*c.b;\n}\nfloat BlendOverlayf(float base, float blend){\n    return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));\n}\nvec3 BlendOverlay(vec3 base, vec3 blend){\n    return vec3(BlendOverlayf(base.r, blend.r), BlendOverlayf(base.g, blend.g), BlendOverlayf(base.b, blend.b));\n}\nfloat BlendVividLightf(float base, float blend){\n    float BlendColorBurnf = (((2.0 * blend) == 0.0) ? (2.0 * blend) : max((1.0 - ((1.0 - base) / (2.0 * blend))), 0.0));\n    float BlendColorDodgef =  (((2.0 * (blend - 0.5)) == 1.0) ? (2.0 * (blend - 0.5)) : min(base / (1.0 - (2.0 * (blend - 0.5))), 1.0));\n    return ((blend < 0.5) ? BlendColorBurnf : BlendColorDodgef);\n}\nvec3 BlendVividLight(vec3 base, vec3 blend){\n    return vec3(BlendVividLightf(base.r, blend.r), BlendVividLightf(base.g, blend.g), BlendVividLightf(base.b, blend.b));\n}\n\nfloat normpdf(in float x, in float sigma) {\n    return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 blurMap() {\n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i){\n        for (int j=-kSize; j <= kSize; ++j){\n            final_colour += kernel[kSize+j] * kernel[kSize+i] * texture2D(uTexture, (vTextureCoord.xy + vec2(float(i),float(j))*px)).rgb;\n        }\n    }\n    return vec3(final_colour/(Z*Z));\n}\n\nvoid main() {\n\n    vec4 base4 = texture2D(uTexture, vTextureCoord.xy);\n\n    vec3 blurMap = blurMap();\n    vec3 base = base4.rgb;\n\n    float intensity = (value < 0.0) ? (value / 2.0) : value;\n    float lum = Lum(base);\n\n    vec3 col = vec3(lum);\n    vec3 mask = vec3(1.0 - pow(lum, 1.8));\n    // invert blurred texture\n    vec3 layer = vec3(1.0 - Lum(blurMap));\n    vec3 detail = clamp(BlendVividLight(col, layer), 0.0, 1.0);\n    // we get negative detail by inverting the detail layer\n    vec3 inverse = mix(1.0 - detail, detail, (intensity+1.0)/2.0);\n\n    finalColor = vec4(BlendOverlay(base, mix(vec3(0.5), inverse, mask)), base4.a);\n}\n";

exports.default = fragment;
//# sourceMappingURL=fragment.frag.js.map
