var fragment = "#define GLSLIFY 1;\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uValue;  // -1.0 ~ 1.0\n\nuniform vec2 uSize;\n\nfloat hazeMap(vec4 base) {\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec2 step = vec2(1.0 / uSize.xy);\n    const int patchRadius = 1; // the half size for shift in 3 x 3 patch.\n    for (int i = -patchRadius; i <= patchRadius; ++i) {\n        for (int j = -patchRadius; j <= patchRadius; ++j) {\n            vec2 uv = clamp(vTextureCoord + (vec2(i, j) * step), 0.0, 1.0);\n            color = min(color, base.rgb);\n        }\n    }\n    return min(color.r, min(color.g, color.b));\n}\n\nvoid main() {\n\n    lowp vec4 base = texture2D(uTexture, vTextureCoord.xy);\n    lowp float haze = hazeMap(base);\n\n    float transmission = 1.0 - 0.95 * haze;\n    const float A = 0.95; //0.95 intensity. We can consider to collect 0.1% brightest pixel from the dark channel image.\n    const float t0 = 0.1; //0.1 in the paper, we can increase it for solving the color bleeding.\n    float t = mix(1.0, max(t0, transmission), uValue);\n    vec3 J = (base.rgb - A) / t + A;\n    finalColor = vec4(J, base.a);\n}\n";

export { fragment as default };
//# sourceMappingURL=fragment.frag.mjs.map
