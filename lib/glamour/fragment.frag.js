'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fragment = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nuniform float uValue;\nuniform vec2 uSize;\n\nfloat normpdf(in float x, in float sigma) {\n    return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 blurMap() {\n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i){\n        for (int j=-kSize; j <= kSize; ++j){\n            final_colour += kernel[kSize+j] * kernel[kSize+i] * texture2D(uTexture, (vTextureCoord.xy + vec2(float(i),float(j))*uSize)).rgb;\n        }\n    }\n    return vec3(final_colour/(Z*Z));\n}\n\nfloat luma(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvoid main() {\n\n    vec4 base = texture2D(uTexture, vTextureCoord);\n    vec3 color = blurMap();\n\n    color = vec3(luma(color));\n\n    color = vec3(\n    (base.r <= 0.5) ? (2.0 * base.r * color.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - color.r)),\n    (base.g <= 0.5) ? (2.0 * base.g * color.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - color.g)),\n    (base.b <= 0.5) ? (2.0 * base.b * color.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - color.b))\n    );\n\n    finalColor = mix(base, vec4(color, base.a), uValue);\n}\n";

exports.default = fragment;
//# sourceMappingURL=fragment.frag.js.map
